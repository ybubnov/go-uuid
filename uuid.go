// Package uuid provides wrapper around Linux kernel-based UUID v4 generator.
//
// Kernel handles a pool of goroutines to efficiently generate universally
// unique identifiers, it is safe for concurrent use. To reduce the resource
// leak it should only be created once and re-used.
package uuid

import (
	"context"
	"errors"
	"os"
	"runtime"
	"sync"
	"sync/atomic"
)

// defaultSrc is a default source for functions UUID and MustUUID used
// to generate UUID v4. By default, on non-Linux operating systems it
// will use "not supported" type to produce an error on attempt to
// generate a new UUID.
var defaultSrc Source = &nosupSource{}

// A Source represents a source of UUID values. This type can be used
// to generate different versions of the UUID.
type Source interface {
	// Next returns a new UUID string. The version and format of the
	// string specifies the interface implementation.
	Next() (string, error)

	// Stop releases all resources reserved by the Source.
	Stop()
}

var (
	// ErrIncomplete is returned when the Linux kernel-based source of
	// UUID returned string of length unequal to UUID v4.
	ErrIncomplete = errors.New("uuid: kernel returned chunk of data")

	// ErrNotSupported is returned when kernel UUID source is used on
	// host that does not support magic procfs file.
	ErrNotSupported = errors.New("uuid: platform is not supported")

	// ErrStopped is returned when Next called after the Stop method.
	ErrStopped = errors.New("uuid: next on stopped source")
)

const (
	// kernelUUIDPath defines path to the file bound to Linux kernel
	// implementation of UUID v4 generator.
	kernelUUIDPath = "/proc/sys/kernel/random/uuid"

	// kernelUUIDLen defines the length of the UUID v4 generated by
	// the Linux kernel.
	kernelUUIDLen = 36
)

type uuidEntry struct {
	value string
	err   error
}

const (
	stateIdle int32 = iota
	stateStarted
	stateStopped
)

// Kernel generates UUIDs of fourth version according to RFC 4122.
//
// This implementation will use the Linux-kernel UUID generator available
// though the interface of proc virtual file system or precisely file
// /proc/sys/kernel/random/uuid.
//
// The generator has an internal state (generated in advance UUIDs, idle
// routines), so Kernel should be reused instead of created as needed.
type Kernel struct {
	// The path defines a filename in the proc file system of Linux
	// used to generate UUID values.
	path string

	// A pool is a sequence of generated UUIDs. In order to improve
	// performance, we will generate multiple UUIDs at a time and
	// put them into this pool.
	ids  chan uuidEntry
	done chan struct{}

	ctx    context.Context
	cancel context.CancelFunc

	// Once instances is used to initialize the non-exported attributes
	// during the first usage of UUID generator methods.
	once sync.Once

	// State used to persist the state of the generator. The state
	// moves always forward from the idle state to the started state.
	// The final state is stopped.
	state int32

	// MaxIdle specifies an amount of UUIDs generated beforehead. The
	// larger the value, the more resources generator consumes until
	// it reaches the saturation.
	MaxIdle int

	// MaxProcs specifies an amount of workers used to generate the
	// UUIDs. Zero value means the maximum number of workers will be
	// defaulted to number of the CPUs installed on the host.
	MaxProcs int
}

// init initializes the non-exported attributes of the type.
func (k *Kernel) init() {
	k.ids = make(chan uuidEntry, k.MaxIdle)
	k.done = make(chan struct{}, k.numProcs())

	// Initialize a context used to terminate the workers,
	// when the user explicitly asks to do this.
	ctx := context.Background()
	k.ctx, k.cancel = context.WithCancel(ctx)

	if k.path == "" {
		k.path = kernelUUIDPath
	}
}

// nextN continuously executes the generator and puts the result
// altogether with a returned error into the queue for consuming.
func (k *Kernel) nextN(ctx context.Context) {
	for {
		// There is one problem with such implementation: it generate
		// a new identifier even if it is not really required.
		s, err := k.next()
		select {
		case k.ids <- uuidEntry{s, err}:
		// Terminate the UUID generator when required.
		case <-ctx.Done():
			k.done <- struct{}{}
			return
		}
	}
}

// next reads the file from the proc virtual file system used to
// generate the UUID v4.
func (k *Kernel) next() (string, error) {
	file, err := os.OpenFile(k.path, os.O_RDONLY, 0)
	if err != nil {
		return "", err
	}

	defer file.Close()

	bits := make([]byte, kernelUUIDLen)
	n, err := file.Read(bits)
	if err != nil {
		return "", err
	}

	if n != kernelUUIDLen {
		return "", ErrIncomplete
	}

	return string(bits), nil
}

// numProcs returns the number of routines used to generate the UUIDs.
func (k *Kernel) numProcs() int {
	numProcs := k.MaxProcs
	if numProcs == 0 {
		numProcs = runtime.NumCPU()
	}

	return numProcs
}

// Start starts specified amount of workers.
func (k *Kernel) start() {
	for i := 0; i < k.numProcs(); i++ {
		go k.nextN(k.ctx)
	}
}

// Next returns a UUID retrieved from Linux kernel internal generator.
func (k *Kernel) Next() (string, error) {
	k.once.Do(k.init)

	// Return an error, when the source have been already stopped.
	if atomic.LoadInt32(&k.state) == stateStopped {
		return "", ErrStopped
	}

	// The routines, used to generate UUIDs will be started only when
	// the first request will come in.
	if atomic.CompareAndSwapInt32(&k.state, stateIdle, stateStarted) {
		k.start()
	}

	entry := <-k.ids
	return entry.value, entry.err
}

// Stop terminates the routines used to generate the UUIDs v4 using the
// embedded Linux kernel generator.
func (k *Kernel) Stop() {
	// Trigger the state to the stopped.
	atomic.StoreInt32(&k.state, stateStopped)

	// Check if the attributes are initialized before cancelling the
	// routines (potentially unstarted).
	k.once.Do(k.init)
	k.cancel()
}

// nopSource is a no-op UUID source.
type nopSource struct {
	val string
}

// Next implements Source interface. It returns the fixed string on
// each call.
func (s *nopSource) Next() (string, error) {
	return s.val, nil
}

// Stop implements Source interface. It does nothing.
func (s *nopSource) Stop() {}

// A NopSource returns UUID source that generates only passed string.
// This function can be used for testing purposes.
func NopSource(s string) Source {
	return &nopSource{s}
}

// nosupSource is a UUID source used as a default source for programs
// compiled for non-Linux hosts. It returns an error on attempt to
// execute the function to generate a new UUID.
type nosupSource struct{}

// Next implements Source interface and always returns an error.
func (s *nosupSource) Next() (string, error) {
	return "", ErrNotSupported
}

// Stop implements Source interface. It does nothing.
func (s *nosupSource) Stop() {}

// New returns a universally unique identifier from the Linux-kernel
// source. When target operating system is not a Linux, it panics.
func New() string {
	id, err := defaultSrc.Next()
	if err != nil {
		panic(err)
	}

	return id
}
